<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spacetime Curvature Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.0.1/lib/browser/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            overflow: hidden;
            background-color: #0a0a1a;
            color: #ffffff;
        }
        
        #canvas-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 320px;
            background-color: rgba(0, 0, 32, 0.85);
            color: #eee;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #3498db;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
            z-index: 10;
            transition: opacity 0.3s;
            max-height: 95vh;
            overflow-y: auto;
        }
        
        h1 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #3498db;
            text-align: center;
        }
        
        p, ul {
            margin-bottom: 10px;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        h2 {
            font-size: 1.2em;
            margin: 12px 0 8px 0;
            color: #55aaff;
        }
        
        .tensor-display {
            font-family: monospace;
            background-color: rgba(0, 20, 60, 0.6);
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .toggle-btn {
            position: absolute;
            top: 10px;
            left: 340px;
            z-index: 10;
        }
        
        .tutorial-highlight {
            background-color: rgba(255, 255, 100, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        #formula-section {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #3498db;
        }
        
        .formula {
            font-family: "Times New Roman", Times, serif;
            font-style: italic;
            padding: 8px;
            background-color: rgba(0, 20, 60, 0.6);
            border-radius: 4px;
            text-align: center;
            margin: 8px 0;
        }
        
        /* Styling for dat.gui */
        .dg.main {
            margin-top: 60px !important;
        }
        
        .dg.main .close-button {
            display: none !important;
        }
        
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 32, 0.85);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #3498db;
            max-width: 200px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .color-box {
            width: 15px;
            height: 15px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="info-panel">
        <h1>Spacetime Curvature Simulator</h1>
        <p>This simulation visualizes how mass and energy curve spacetime according to Einstein's theory of General Relativity.</p>
        
        <h2>Key Concepts</h2>
        <ul>
            <li><strong>Mass-Energy Distribution:</strong> Represented by density and location of masses</li>
            <li><strong>Stress-Energy Tensor:</strong> Describes energy, momentum, and stress at each point</li>
            <li><strong>Metric Tensor:</strong> Defines the geometry of spacetime</li>
        </ul>
        
        <h2>Interactive Controls</h2>
        <ul>
            <li><strong>Mass Parameters:</strong> Change mass values and positions</li>
            <li><strong>View Options:</strong> Toggle grid lines, particle flows</li>
            <li><strong>Camera:</strong> Drag to rotate, scroll to zoom</li>
        </ul>
        
        <h2>Current Stress-Energy Tensor</h2>
        <div class="tensor-display" id="stress-energy-display">
            Calculating...
        </div>
        
        <h2>Current Metric Tensor</h2>
        <div class="tensor-display" id="metric-display">
            Calculating...
        </div>
        
        <div id="formula-section">
            <h2>Einstein Field Equations</h2>
            <div class="formula">
                G<sub>μν</sub> = 8πG T<sub>μν</sub>
            </div>
            <p>Where G<sub>μν</sub> is the Einstein tensor representing spacetime curvature, and T<sub>μν</sub> is the stress-energy tensor representing the distribution of matter and energy.</p>
        </div>
        
        <button id="reset-btn">Reset Simulation</button>
        <button id="toggle-particles-btn">Toggle Particle Flow</button>
    </div>
    
    <button class="toggle-btn" id="toggle-info">Hide Info</button>
    
    <div id="legend">
        <h2>Legend</h2>
        <div class="legend-item"><div class="color-box" style="background-color: #ff5722;"></div>Mass Object</div>
        <div class="legend-item"><div class="color-box" style="background-color: #4CAF50;"></div>Particle Flow</div>
        <div class="legend-item"><div class="color-box" style="background-color: #3498db;"></div>Spacetime Grid</div>
    </div>
    
    <script>
        // Main simulation variables
        let scene, camera, renderer, controls;
        let spacetimeGrid, massObjects = [];
        let particles = [];
        let clock = new THREE.Clock();
        
        // Physics parameters (initial values)
        const params = {
            mass1: 25, 
            mass2: 0,
            mass3: 0,  // Set to 0 initially to have only 2 masses by default
            mass1Position: { x: 0, y: 0, z: 0 },
            mass2Position: { x: 10, y: 0, z: 10 },
            mass3Position: { x: -10, y: 0, z: -10 },
            spacetimeResolution: 20,
            gravitationalConstant: 1,
            particleCount: 200,
            particleSpeed: 0.5,
            showParticles: true,
            showGrid: true,
            gridOpacity: 0.7,
            spaceTimeStiffness: 0.5  // Parameter for how "stiff" spacetime is
        };
        
        // Initialize the scene
        init();
        animate();
        
        function init() {
            // Create the scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            // Create the camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);
            
            // Create the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Create coordinate axes for reference
            const axesHelper = new THREE.AxesHelper(20);
            scene.add(axesHelper);
            
            // Create the spacetime grid
            createSpacetimeGrid();
            
            // Create mass objects
            createMassObjects();
            
            // Create particles that follow geodesics
            createParticles();
            
            // Set up GUI controls
            setupGUI();
            
            // Set up event listeners
            window.addEventListener('resize', onWindowResize);
            
            document.getElementById('toggle-info').addEventListener('click', function() {
                const panel = document.getElementById('info-panel');
                const button = document.getElementById('toggle-info');
                
                if (panel.style.display === 'none') {
                    panel.style.display = 'block';
                    button.textContent = 'Hide Info';
                } else {
                    panel.style.display = 'none';
                    button.textContent = 'Show Info';
                }
            });
            
            document.getElementById('reset-btn').addEventListener('click', resetSimulation);
            document.getElementById('toggle-particles-btn').addEventListener('click', toggleParticles);
            
            // Initial update of tensor displays
            updateTensorDisplays();
        }
        
        function createSpacetimeGrid() {
            // Remove existing grid if any
            if (spacetimeGrid) {
                scene.remove(spacetimeGrid);
            }
            
            spacetimeGrid = new THREE.Group();
            
            const gridSize = 40;
            const segments = params.spacetimeResolution;
            
            // Create a grid geometry
            const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize, segments, segments);
            gridGeometry.rotateX(-Math.PI / 2); // Make the grid horizontal
            
            // Create grid material
            const gridMaterial = new THREE.MeshBasicMaterial({
                color: 0x3498db,
                wireframe: true,
                transparent: true,
                opacity: params.gridOpacity
            });
            
            // Create the grid mesh
            const gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
            spacetimeGrid.add(gridMesh);
            
            // Deform the grid based on mass positions
            updateSpacetimeDeformation();
            
            scene.add(spacetimeGrid);
        }
        
        function updateSpacetimeDeformation() {
            if (!spacetimeGrid) return;
            
            const gridMesh = spacetimeGrid.children[0];
            const positions = gridMesh.geometry.attributes.position.array;
            
            // Calculate deformation of the grid based on masses
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i+2];
                
                // Reset y position
                positions[i+1] = 0;
                
                // Apply deformation from each mass
                for (let mass of massObjects) {
                    const mx = mass.position.x;
                    const mz = mass.position.z;
                    
                    // Distance from the current vertex to the mass
                    const dx = x - mx;
                    const dz = z - mz;
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    
                    // Skip if too close to avoid extreme deformation
                    if (distance < 1.5) continue;
                    
                    // Calculate deformation based on mass and distance
                    // Using a modified version of gravitational potential
                    const deformation = -mass.userData.mass / 
                                       (distance * Math.pow(params.spaceTimeStiffness, 1.5));
                    
                    // Add deformation to y position
                    positions[i+1] += deformation;
                }
            }
            
            // Update the geometry
            gridMesh.geometry.attributes.position.needsUpdate = true;
            gridMesh.geometry.computeVertexNormals();
        }
        
        function createMassObjects() {
            // Remove existing masses
            for (let mass of massObjects) {
                scene.remove(mass);
            }
            massObjects = [];
            
            // Create mass 1
            if (params.mass1 > 0) {
                const mass1 = createMassObject(params.mass1, 
                                              params.mass1Position.x, 
                                              params.mass1Position.y, 
                                              params.mass1Position.z,
                                              0xff5722);
                massObjects.push(mass1);
                scene.add(mass1);
            }
            
            // Create mass 2
            if (params.mass2 > 0) {
                const mass2 = createMassObject(params.mass2, 
                                              params.mass2Position.x, 
                                              params.mass2Position.y, 
                                              params.mass2Position.z,
                                              0xE91E63);
                massObjects.push(mass2);
                scene.add(mass2);
            }
            
            // Create mass 3
            if (params.mass3 > 0) {
                const mass3 = createMassObject(params.mass3, 
                                              params.mass3Position.x, 
                                              params.mass3Position.y, 
                                              params.mass3Position.z,
                                              0x9C27B0);
                massObjects.push(mass3);
                scene.add(mass3);
            }
        }
        
        function createMassObject(mass, x, y, z, color) {
            // Size based on mass (scaled for visualization)
            const radius = Math.pow(mass, 1/3) * 0.8;
            
            // Create geometry and material
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.2,
                shininess: 30
            });
            
            // Create the mesh
            const massObject = new THREE.Mesh(geometry, material);
            massObject.position.set(x, y, z);
            
            // Add mass data
            massObject.userData = { mass: mass };
            
            return massObject;
        }
        
        function createParticles() {
            // Remove existing particles
            for (let particle of particles) {
                scene.remove(particle);
            }
            particles = [];
            
            if (!params.showParticles) return;
            
            const particleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x4CAF50,
                transparent: true,
                opacity: 0.8
            });
            
            // Create particles
            for (let i = 0; i < params.particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random position within a horizontal ring
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 10;
                
                particle.position.x = Math.cos(angle) * radius;
                particle.position.z = Math.sin(angle) * radius;
                
                // Get y position from the deformed grid at this x,z
                particle.position.y = getYPositionOnGrid(particle.position.x, particle.position.z);
                
                // Add velocity data
                const tangentialSpeed = params.particleSpeed * (0.8 + Math.random() * 0.4);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        -Math.sin(angle) * tangentialSpeed,
                        0,
                        Math.cos(angle) * tangentialSpeed
                    ),
                    // Add a small random perturbation to the orbit
                    perturbation: Math.random() * 0.1
                };
                
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function getYPositionOnGrid(x, z) {
            // Function to get the y position on the deformed grid at point (x,z)
            let y = 0;
            
            // Apply deformation from each mass
            for (let mass of massObjects) {
                const mx = mass.position.x;
                const mz = mass.position.z;
                
                // Distance from the point to the mass
                const dx = x - mx;
                const dz = z - mz;
                const distance = Math.sqrt(dx*dx + dz*dz);
                
                // Skip if too close to avoid extreme deformation
                if (distance < 1.5) continue;
                
                // Calculate deformation based on mass and distance
                const deformation = -mass.userData.mass / 
                                   (distance * Math.pow(params.spaceTimeStiffness, 1.5));
                
                // Add deformation to y position
                y += deformation;
            }
            
            return y;
        }
        
        function updateParticlePositions(delta) {
            if (!params.showParticles) return;
            
            for (let particle of particles) {
                // Get current position and velocity
                const pos = particle.position;
                const vel = particle.userData.velocity;
                
                // Calculate gravitational acceleration from all masses
                const acceleration = new THREE.Vector3(0, 0, 0);
                
                for (let mass of massObjects) {
                    const massPos = mass.position;
                    const dx = massPos.x - pos.x;
                    const dy = massPos.y - pos.y;
                    const dz = massPos.z - pos.z;
                    
                    // Distance to mass
                    const distanceSq = dx*dx + dy*dy + dz*dz;
                    const distance = Math.sqrt(distanceSq);
                    
                    // Skip if too close
                    if (distance < 2) continue;
                    
                    // Gravitational force (direction)
                    const forceMagnitude = params.gravitationalConstant * mass.userData.mass / distanceSq;
                    
                    // Add to acceleration (F = ma, so a = F/m, but we're setting m=1 for simplicity)
                    acceleration.x += forceMagnitude * dx / distance;
                    acceleration.y += forceMagnitude * dy / distance;
                    acceleration.z += forceMagnitude * dz / distance;
                }
                
                // Update velocity based on acceleration
                vel.x += acceleration.x * delta;
                vel.y += acceleration.y * delta;
                vel.z += acceleration.z * delta;
                
                // Add a small perturbation for visual interest
                vel.x += (Math.random() - 0.5) * particle.userData.perturbation * delta;
                vel.z += (Math.random() - 0.5) * particle.userData.perturbation * delta;
                
                // Update position based on velocity
                pos.x += vel.x * delta;
                pos.y += vel.y * delta;
                pos.z += vel.z * delta;
                
                // Update y position based on the deformed grid
                pos.y = getYPositionOnGrid(pos.x, pos.z);
                
                // If particle goes too far, reset it
                if (pos.x < -30 || pos.x > 30 || pos.z < -30 || pos.z > 30) {
                    // Reset particle to a new starting position
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 15 + Math.random() * 10;
                    
                    pos.x = Math.cos(angle) * radius;
                    pos.z = Math.sin(angle) * radius;
                    pos.y = getYPositionOnGrid(pos.x, pos.z);
                    
                    // Reset velocity to tangential
                    const tangentialSpeed = params.particleSpeed * (0.8 + Math.random() * 0.4);
                    vel.x = -Math.sin(angle) * tangentialSpeed;
                    vel.y = 0;
                    vel.z = Math.cos(angle) * tangentialSpeed;
                }
            }
        }
        
        function calculateStressEnergyTensor() {
            // This is a simplified model of the stress-energy tensor
            // In a real GR calculation, this would be much more complex
            
            // T_00 = energy density
            // T_ii = pressure in i direction
            // T_i0 = momentum density in i direction
            
            let tensor = [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ];
            
            // Add contribution from each mass
            for (let mass of massObjects) {
                // For this simplified model, we'll put energy density in T_00
                // and pressure components in T_ii
                tensor[0][0] += mass.userData.mass;
                
                // Add some pressure terms (simplified)
                tensor[1][1] += mass.userData.mass * 0.2;
                tensor[2][2] += mass.userData.mass * 0.2;
                tensor[3][3] += mass.userData.mass * 0.2;
                
                // Add momentum terms for visualization (these would typically be 0 for static masses)
                // We'll add small values for visual interest
                const pos = mass.position;
                tensor[0][1] += pos.x * 0.01;
                tensor[0][2] += pos.y * 0.01;
                tensor[0][3] += pos.z * 0.01;
                
                // Make it symmetric (as required by GR)
                tensor[1][0] = tensor[0][1];
                tensor[2][0] = tensor[0][2];
                tensor[3][0] = tensor[0][3];
            }
            
            return tensor;
        }
        
        function calculateMetricTensor() {
            // This is a simplified model of the metric tensor
            // In real GR, you would solve the Einstein Field Equations
            
            // Start with Minkowski metric (flat spacetime)
            let metric = [
                [-1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ];
            
            // Add simplified perturbations due to mass
            // (Again, this is very simplified compared to real GR)
            let totalMass = 0;
            for (let mass of massObjects) {
                totalMass += mass.userData.mass;
            }
            
            // Schwarzschild-like perturbation
            const schwarzschildRadius = 2 * params.gravitationalConstant * totalMass;
            
            // Modify the metric components
            // In real GR, these would come from solving EFEs
            metric[0][0] = -1 + schwarzschildRadius / 20;
            metric[1][1] = 1 + schwarzschildRadius / 40;
            metric[2][2] = 1 + schwarzschildRadius / 40;
            metric[3][3] = 1 + schwarzschildRadius / 40;
            
            return metric;
        }
        
        function updateTensorDisplays() {
            // Update stress-energy tensor display
            const stressEnergyTensor = calculateStressEnergyTensor();
            let seDisplay = '';
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    seDisplay += stressEnergyTensor[i][j].toFixed(3).padStart(8);
                }
                seDisplay += '\n';
            }
            document.getElementById('stress-energy-display').textContent = seDisplay;
            
            // Update metric tensor display
            const metricTensor = calculateMetricTensor();
            let metricDisplay = '';
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    metricDisplay += metricTensor[i][j].toFixed(3).padStart(8);
                }
                metricDisplay += '\n';
            }
            document.getElementById('metric-display').textContent = metricDisplay;
        }
        
        function setupGUI() {
            const gui = new dat.GUI();
            
            // Mass 1 folder
            const mass1Folder = gui.addFolder('Mass 1');
            mass1Folder.add(params, 'mass1', 0, 50).name('Mass Value').onChange(function() {
                createMassObjects();
                updateSpacetimeDeformation();
                updateTensorDisplays();
            });
            mass1Folder.add(params.mass1Position, 'x', -20, 20).name('X Position').onChange(function() {
                updateMassPositions();
            });
            mass1Folder.add(params.mass1Position, 'z', -20, 20).name('Z Position').onChange(function() {
                updateMassPositions();
            });
            mass1Folder.open();
            
            // Mass 2 folder
            const mass2Folder = gui.addFolder('Mass 2');
            mass2Folder.add(params, 'mass2', 0, 50).name('Mass Value').onChange(function() {
                createMassObjects();
                updateSpacetimeDeformation();
                updateTensorDisplays();
            });
            mass2Folder.add(params.mass2Position, 'x', -20, 20).name('X Position').onChange(function() {
                updateMassPositions();
            });
            mass2Folder.add(params.mass2Position, 'z', -20, 20).name('Z Position').onChange(function() {
                updateMassPositions();
            });
            mass2Folder.open();
            
            // Mass 3 folder
            const mass3Folder = gui.addFolder('Mass 3');
            mass3Folder.add(params, 'mass3', 0, 50).name('Mass Value').onChange(function() {
                createMassObjects();
                updateSpacetimeDeformation();
                updateTensorDisplays();
            });
            mass3Folder.add(params.mass3Position, 'x', -20, 20).name('X Position').onChange(function() {
                updateMassPositions();
            });
            mass3Folder.add(params.mass3Position, 'z', -20, 20).name('Z Position').onChange(function() {
                updateMassPositions();
            });
            
            // Spacetime properties folder
            const spacetimeFolder = gui.addFolder('Spacetime Properties');
            spacetimeFolder.add(params, 'spacetimeResolution', 10, 50).step(1).name('Grid Resolution').onChange(function() {
                createSpacetimeGrid();
            });
            spacetimeFolder.add(params, 'spaceTimeStiffness', 0.1, 2).name('Space Stiffness').onChange(function() {
                updateSpacetimeDeformation();
            });
            spacetimeFolder.add(params, 'gravitationalConstant', 0.1, 5).name('G Constant').onChange(function() {
                updateSpacetimeDeformation();
                updateTensorDisplays();
            });
            spacetimeFolder.add(params, 'gridOpacity', 0, 1).name('Grid Opacity').onChange(function() {
                if (spacetimeGrid) {
                    spacetimeGrid.children[0].material.opacity = params.gridOpacity;
                }
            });
            
            // Particle properties folder
            const particleFolder = gui.addFolder('Particle Properties');
            particleFolder.add(params, 'particleCount', 0, 500).step(10).name('Particle Count').onChange(function() {
                createParticles();
            });
            particleFolder.add(params, 'particleSpeed', 0.1, 2).name('Particle Speed').onChange(function() {
                createParticles();
            });
            
            // View options folder
            const viewFolder = gui.addFolder('View Options');
            viewFolder.add(params, 'showParticles').name('Show Particles').onChange(function() {
                createParticles();
            });
            viewFolder.add(params, 'showGrid').name('Show Grid').onChange(function() {
                spacetimeGrid.visible = params.showGrid;
            });
        }
        
        function updateMassPositions() {
            if (massObjects.length > 0 && params.mass1 > 0) {
                massObjects[0].position.set(
                    params.mass1Position.x,
                    params.mass1Position.y,
                    params.mass1Position.z
                );
            }
            
            if (massObjects.length > 1 && params.mass2 > 0) {
                massObjects[1].position.set(
                    params.mass2Position.x,
                    params.mass2Position.y,
                    params.mass2Position.z
                );
            }
            
            if (massObjects.length > 2 && params.mass3 > 0) {
                massObjects[2].position.set(
                    params.mass3Position.x,
                    params.mass3Position.y,
                    params.mass3Position.z
                );
            }
            
            updateSpacetimeDeformation();
            updateTensorDisplays();
        }
        
        function resetSimulation() {
            // Reset parameters to default values
            params.mass1 = 25;
            params.mass2 = 0;
            params.mass3 = 0;
            params.mass1Position = { x: 0, y: 0, z: 0 };
            params.mass2Position = { x: 10, y: 0, z: 10 };
            params.mass3Position = { x: -10, y: 0, z: -10 };
            params.spacetimeResolution = 20;
            params.gravitationalConstant = 1;
            params.particleCount = 200;
            params.particleSpeed = 0.5;
            params.showParticles = true;
            params.showGrid = true;
            params.gridOpacity = 0.7;
            params.spaceTimeStiffness = 0.5;
            
            // Update GUI
            for (let i = 0; i < dat.GUI.__all__.length; i++) {
                dat.GUI.__all__[i].updateDisplay();
            }
            
            // Reset simulation components
            createSpacetimeGrid();
            createMassObjects();
            createParticles();
            updateTensorDisplays();
        }
        
        function toggleParticles() {
            params.showParticles = !params.showParticles;
            
            // Update particles
            if (params.showParticles) {
                createParticles();
            } else {
                for (let particle of particles) {
                    scene.remove(particle);
                }
                particles = [];
            }
            
            // Update GUI
            for (let i = 0; i < dat.GUI.__all__.length; i++) {
                dat.GUI.__all__[i].updateDisplay();
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update orbital controls
            controls.update();
            
            // Update particle positions
            updateParticlePositions(delta);
            
            // Render the scene
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>