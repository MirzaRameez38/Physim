<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton's First Law - Physics Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            max-width: 350px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        .slider-container {
            margin: 10px 0;
        }
        button {
            padding: 8px 12px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        h1 {
            margin-top: 0;
            color: #333;
        }
        .force-button {
            width: 60px;
            height: 40px;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="info">
        <h1>Newton's First Law of Motion</h1>
        <p><strong>Law of Inertia:</strong> An object at rest stays at rest and an object in motion stays in motion with the same speed and in the same direction unless acted upon by an unbalanced force.</p>
        <div id="object-info">
            <div id="velocity">Velocity: 0 m/s</div>
            <div id="friction-force">Friction Force: 0 N</div>
        </div>
        <hr>
        <p><strong>Instructions:</strong> Apply force to the object using the arrow buttons. Adjust surface friction to see how it affects motion.</p>
    </div>
    
    <div id="controls">
        <div class="slider-container">
            <label for="friction">Surface Friction:</label>
            <input type="range" id="friction" min="0" max="1" value="0.1" step="0.01">
            <span id="friction-value">0.10</span>
        </div>
        
        <div class="slider-container">
            <label for="mass">Object Mass (kg):</label>
            <input type="range" id="mass" min="1" max="10" value="2" step="0.5">
            <span id="mass-value">2.0</span>
        </div>
        
        <div>
            <label>Apply Force:</label>
            <div>
                <button id="force-left" class="force-button">◀ Left</button>
                <button id="force-right" class="force-button">Right ▶</button>
            </div>
        </div>
        
        <button id="reset">Reset Simulation</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize Three.js scene
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // Create camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 0, 0);
        
        // Create renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        scene.add(directionalLight);
        
        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(30, 15);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x559955,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Create surface
        const surfaceGeometry = new THREE.BoxGeometry(20, 0.1, 5);
        const surfaceMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8888ff,
            roughness: 0.5,
            metalness: 0.1
        });
        const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
        surface.position.y = 0;
        surface.receiveShadow = true;
        scene.add(surface);
        
        // Create borders for the surface
        const borderMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
        
        const leftBorder = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.5, 5),
            borderMaterial
        );
        leftBorder.position.set(-10.15, 0.25, 0);
        leftBorder.receiveShadow = true;
        leftBorder.castShadow = true;
        scene.add(leftBorder);
        
        const rightBorder = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.5, 5),
            borderMaterial
        );
        rightBorder.position.set(10.15, 0.25, 0);
        rightBorder.receiveShadow = true;
        rightBorder.castShadow = true;
        scene.add(rightBorder);
        
        // Create moving object
        let objSize = 1;
        const objectGeometry = new THREE.BoxGeometry(objSize, objSize, objSize);
        const objectMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff5533,
            roughness: 0.4,
            metalness: 0.6
        });
        const movingObject = new THREE.Mesh(objectGeometry, objectMaterial);
        movingObject.position.set(0, objSize/2, 0);
        movingObject.castShadow = true;
        movingObject.receiveShadow = true;
        scene.add(movingObject);
        
        // Add arrow to show velocity
        const arrowDirection = new THREE.Vector3(1, 0, 0);
        arrowDirection.normalize();
        const arrowOrigin = new THREE.Vector3(0, 0.5, 0);
        const arrowLength = 0;
        const arrowColor = 0xff0000;
        const arrowHelper = new THREE.ArrowHelper(arrowDirection, arrowOrigin, arrowLength, arrowColor, 0.3, 0.2);
        scene.add(arrowHelper);
        
        // Physics variables
        let objectMass = 2;
        let friction = 0.1;
        let velocity = 0;
        let acceleration = 0;
        let appliedForce = 0;
        let lastTime = performance.now();
        
        // UI elements
        const frictionSlider = document.getElementById('friction');
        const frictionValue = document.getElementById('friction-value');
        const massSlider = document.getElementById('mass');
        const massValue = document.getElementById('mass-value');
        const forceLeftBtn = document.getElementById('force-left');
        const forceRightBtn = document.getElementById('force-right');
        const resetButton = document.getElementById('reset');
        const velocityDisplay = document.getElementById('velocity');
        const frictionForceDisplay = document.getElementById('friction-force');
        
        // Event listeners
        frictionSlider.addEventListener('input', updateFriction);
        massSlider.addEventListener('input', updateMass);
        forceLeftBtn.addEventListener('mousedown', () => applyForce(-10));
        forceLeftBtn.addEventListener('mouseup', () => applyForce(0));
        forceLeftBtn.addEventListener('mouseleave', () => applyForce(0));
        forceRightBtn.addEventListener('mousedown', () => applyForce(10));
        forceRightBtn.addEventListener('mouseup', () => applyForce(0));
        forceRightBtn.addEventListener('mouseleave', () => applyForce(0));
        resetButton.addEventListener('click', resetSimulation);
        
        // Handle touch events for mobile
        forceLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); applyForce(-10); });
        forceLeftBtn.addEventListener('touchend', () => applyForce(0));
        forceRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); applyForce(10); });
        forceRightBtn.addEventListener('touchend', () => applyForce(0));
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Functions
        function updateFriction() {
            friction = parseFloat(frictionSlider.value);
            frictionValue.textContent = friction.toFixed(2);
            
            // Update surface material based on friction
            surface.material.roughness = friction;
        }
        
        function updateMass() {
            objectMass = parseFloat(massSlider.value);
            massValue.textContent = objectMass.toFixed(1);
            
            // Update object size based on mass
            objSize = 0.75 + (objectMass / 10);
            movingObject.scale.set(objSize, objSize, objSize);
        }
        
        function applyForce(force) {
            appliedForce = force;
        }
        
        function resetSimulation() {
            velocity = 0;
            acceleration = 0;
            appliedForce = 0;
            movingObject.position.x = 0;
            
            updateUI();
        }
        
        function updatePhysics() {
            const now = performance.now();
            const deltaTime = Math.min((now - lastTime) / 1000, 0.1); // Convert to seconds, cap at 0.1s
            lastTime = now;
            
            // Calculate friction force
            const frictionForce = friction * objectMass * 9.8 * (velocity > 0 ? -1 : velocity < 0 ? 1 : 0);
            
            // Calculate net force
            const netForce = appliedForce + frictionForce;
            
            // Calculate acceleration (F=ma => a=F/m)
            acceleration = netForce / objectMass;
            
            // Update velocity
            velocity += acceleration * deltaTime;
            
            // Apply very small friction to gradually stop object even without explicit friction
            if (Math.abs(velocity) < 0.01 && appliedForce === 0) {
                velocity = 0;
            }
            
            // Update position
            movingObject.position.x += velocity * deltaTime;
            
            // Constrain to borders
            if (movingObject.position.x > 9.5) {
                movingObject.position.x = 9.5;
                velocity *= -0.5; // Bounce with energy loss
            } else if (movingObject.position.x < -9.5) {
                movingObject.position.x = -9.5;
                velocity *= -0.5; // Bounce with energy loss
            }
            
            // Update arrow (velocity vector)
            arrowHelper.position.copy(movingObject.position);
            if (velocity !== 0) {
                arrowHelper.setDirection(new THREE.Vector3(velocity > 0 ? 1 : -1, 0, 0));
                arrowHelper.setLength(Math.abs(velocity) * 0.5);
            } else {
                arrowHelper.setLength(0);
            }
            
            // Update UI
            updateUI(frictionForce);
        }
        
        function updateUI(frictionForce = 0) {
            velocityDisplay.textContent = `Velocity: ${velocity.toFixed(2)} m/s`;
            frictionForceDisplay.textContent = `Friction Force: ${Math.abs(frictionForce).toFixed(2)} N`;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            updatePhysics();
            
            renderer.render(scene, camera);
        }
        
        // Initialize
        updateFriction();
        updateMass();
        animate();
    </script>
</body>
</html>
